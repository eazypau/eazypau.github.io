import destr from 'destr';
import { withBase, withQuery } from 'ufo';

class FetchError extends Error {
  constructor() {
    super(...arguments);
    this.name = "FetchError";
  }
}
function createFetchError(request, error, response) {
  let message = "";
  if (request && response) {
    message = `${response.status} ${response.statusText} (${request.toString()})`;
  }
  if (error) {
    message = `${error.message} (${message})`;
  }
  const fetchError = new FetchError(message);
  Object.defineProperty(fetchError, "request", { get() {
    return request;
  } });
  Object.defineProperty(fetchError, "response", { get() {
    return response;
  } });
  Object.defineProperty(fetchError, "data", { get() {
    return response && response.data;
  } });
  return fetchError;
}

const payloadMethods = ["patch", "post", "put"];
function setHeader(options, _key, value) {
  const key = _key.toLowerCase();
  options.headers = options.headers || {};
  if ("set" in options.headers) {
    options.headers.set(key, value);
  } else if (Array.isArray(options.headers)) {
    const existingHeader = options.headers.find(([header]) => header.toLowerCase() === key);
    if (existingHeader) {
      existingHeader[1] = value;
    } else {
      options.headers.push([key, value]);
    }
  } else {
    const existingHeader = Object.keys(options.headers).find((header) => header.toLowerCase() === key);
    options.headers[existingHeader || key] = value;
  }
}
function createFetch({ fetch }) {
  function onError(request, opts, error, response) {
    if (opts.retry !== false) {
      const hasPayload = payloadMethods.includes((opts.method || "").toLowerCase());
      const retries = typeof opts.retry === "number" ? opts.retry : hasPayload ? 0 : 1;
      if (retries > 0) {
        return $fetchRaw(request, {
          ...opts,
          retry: retries - 1
        });
      }
    }
    const err = createFetchError(request, error, response);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(err, $fetchRaw);
    }
    throw err;
  }
  const $fetchRaw = async function $fetchRaw2(request, opts = {}) {
    if (typeof request === "string") {
      if (opts.baseURL) {
        request = withBase(request, opts.baseURL);
      }
      if (opts.params) {
        request = withQuery(request, opts.params);
      }
      const hasPayload = payloadMethods.includes((opts.method || "").toLowerCase());
      if (opts.body && typeof opts.body === "object" && hasPayload) {
        opts.body = JSON.stringify(opts.body);
        setHeader(opts, "content-type", "application/json");
      }
    }
    const response = await fetch(request, opts).catch((error) => onError(request, opts, error, void 0));
    const text = await response.text();
    const parseFn = opts.parseResponse || destr;
    response.data = parseFn(text);
    return response.ok ? response : onError(request, opts, void 0, response);
  };
  const $fetch = function $fetch2(request, opts) {
    return $fetchRaw(request, opts).then((r) => r.data);
  };
  $fetch.raw = $fetchRaw;
  return $fetch;
}

export { FetchError as F, createFetchError as a, createFetch as c, setHeader as s };
